/**
\mainpage Mainpage

\section mainPageOverview Overview

The policy search toolbox is a very flexible and modular tool to implement and prototype policy search algorithms. It allows fast prototyping of different types of policy search algorithms
that learn on different time scales or levels of hierarchy. The toolbox provides common interfaces for handling the data structure, learning algorithms, function approximators, distributions, 
feature generators, optimizers, samplers and for doing experiments. Each of these packages is designed in a highly modular way such that it can be easily extended. The toolbox is structured in several core packages:
- Common: The common package provides the base class for all other objects in the toolbox. It implements a
  global parameter pool shared across all instances of objects from the toolbox.
- Data: The data package is the core of the toolbox. It contains the classes Data.Data, Data.DataManager, and Data.DataManipulator. The data handling is very fleixible. In the data manager we can define different data entries that should be maintained, for example "states" and "actions". This data entries can be defined on different levels of hierarchy, for example, for the episodes, for the steps or for sub-steps. Als the hierarchy is flexible and can be redefined. The data class itself maintains the data and can be used for simple data access and setting the data. We provide functions for accessing the data entries in a hierarchical way (as they are defined in the hierachy). Please consult the test-file "+tests/testDataManager.m" for more information. If we have defined all entries of the data structure we can manipulate the data with the DataManipulator interface. Each class that handles data should be sub-class of this interface. With this interface, we can publish data manipulation functions. A data manipulation function is a function that takes several data entries as input. The output of such a function is also a collection of data entries that is subsequently stored in the datat structure. For sample, we can register a data-manipulation function called "getReward" with the input arguments "states" and "actions" and the output argument "rewards". If we now call this function with the whole data structure ('callDataFunction'), then the input arguments are parsed from the structure, passed to the function which computes the given output arguments. The output arguments are immediatly stored back in the data structure. 
- Sampler: The samplers are essential to defined the data flow for generating new samples (rollouts/episodes...). I sampler maintains a ordered list of data manipulation functions which are called 
sequentially. The samplers also work on different levels of the hierarchy. For example, we can define a sampler that first samples a context s with the data manipulation function "sampleContext", then samples parameters for a movement primitive and subsequently samples the single steps of the episodes. For more information please consult the test files of the Sampler package.
- Functions / Distributions: Functions and Distributions are both instances of the Functions.Mapping interface. A mapping is a specialization of the data manipulation interface. Each function that is registered in the mapping interface has the same input arguments from the data. Functions have already a pre-registered mapping function getExpectation, that should return the output of the function. Distributions have another pre-registered function, called sampleFromDistribution. Both functions are abstract and *need* to be implemented by the subclasses. Some subclasses inherent from both interfaces. For example, linear Gaussian models  implement the getExpectation as well as the sampleFromDistribution interface, and, therefore, can be used as functions and as distributions. Currently we provide basic functionality for linear Gaussian distributions (linear in some features) and GPs. These classes only provide the functionality to use them as function or distribution, learning of these functions takes place in the Learner package.
- Learner: This package provides algorithms for several supervised (Learner.SupervisedLearner) and reinforcement learning algorithms. All learning algorithms need to implement the updateModel
function that gets the whole data structure as input. From the data structure, they either need to update a policy, a forward model, a state distribution or maybe a value function. The learners always get an instance of the function approximator that they should learn. At each call of the update-model function, they should update the parameters of this function approximator. Please consult the sub-packages and the test-scripts for more information.
- Environments: Environments provide the basic interfacce for defining environements. Environments can again be defined on the different levels of the hierachy. Episodic environements that can be treated as a bandit just get the context and the parameters as input and return the returns. However, typically the environments are defined by transition functions on the level of the steps. In this case, the environment gets states and actions as inputs and it has to return the next states. Please consult the package and the test files for more information.
- Experiments: This package provides the basic functionality for defining experiments. An experiments is always a combination of a LearningSetup and a TaskSetup. For example, in order to learn ball i the cup for with parameter based REPS, we need a parameter based learning setup with the task setup from SL. For each experiment, we can define several evaluations. An evaluation is a specific setup of the parameter values of the algorithms. For example, we can define an evaluation, that performs 10 trials for different values of epsilon for REPS. These different trials are stored in a data-base like manner in different directories under the base directory /+Experiments/data (note: you must link or create this directory!). The experiment interface already provides sophisticated tools for plotting ans visualizing the results of the experiments (see Plotter package).

You should also take a look at the Tutorials, which provide an overview on the basic functionality of the toolbox.
 
 
\section mainPageDownload Download and Installation

The toolbox can be downloaded over our git server. You clone it by "git clone git@git.ias.informatik.tu-darmstadt.de:ausy/policysearchtoolboxpublic.git". 
The repository is public so everybody can clone it. Afterwards you just need to run the mexAll script to mex all relevant c files.
Now you are read to go.


*/
