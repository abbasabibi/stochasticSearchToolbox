/**
\package Sampler 

The Sampler package contains the sampler classes. A sampler is a collection of data manipulation functions that are called in a pre-defined order such that we can generate the desired data. There are two different types of samplers, which are also the base classes for the samplers. IndependentSampler creates samples that are independent from each other, for example, different episodes following the same policy. In this case, all samples can be generated at once (standard behaviour), i.e., the data manipulation functions are called for all samples at once. The SequentialSampler creates samples that are sequentially generated, i.e., the single steps of an episode. Here, we can still generate all samples for the same step (but different episodes) at once, but the samples of different time steps have to be computed sequentially. For both sampling techniques, we can deactivate the parellel sampling scheme. 

Each sampler has a specified number of named sampling pools. Each sampling pool also has a specified priority (between 1 and 100) which specifies the order of execution of the sampling pools. 
We can add an arbitrary number of data manipulation functions to each sampling pool (with the function Sampler.addSamplerFunction). The order of adding the data manipulation functions also specifies the order of the function calls, but we also have the possibility to add a data manipulation function at the beginning of the list of functions. Each sampler has a property numSamples that specifies the number of samples that should be created. Samples are created by the function Sampler.createSamples. This function first reserves the correct amount of memory in the data structure and then loops over all defined sampler pools. The function can also be called with the standard data indicing such that only a subset of the samples are created. 
There are 3 main implementations of the sampler classes that we will generally need. Each of these sampling classes already create a data manager and initialize it with some basic data entries.
- Sampler.EpisodeSampler: This class is a subclass of IndependentSampler and can be used to sample a different number of episodes in parallel or sequentially. It has sampling pools for initializing the episodes (InitEpisode, typically used for sampling a context), sampling from a parameter policy (Policy), sampling the steps of an episode (Episode), sampling the final reward (FinalReward) and finally sampling the returns ('Return'). For each of these sampling pools, the EpisodeSampler provides functions to set the corresponding data manipulation function. Typically, we only use one data manipulation function per pool, but there is the option to add more then one function to a pool (see functions for setting the corresponding data manipulation functions). The EpisodeSampler also adds the iterationNumber as a data entry to the data manager. The iteration number is automatically increased by the corresponding learning scenario and automatically sets it in the data structure each time the createSamples function is called. The EpisodeSampler also adds a data alias 'contexts' which is initially left empty. The environment classes can then add a different number of data entries to the context alias (see Data.DataManager for data aliases).
- Sampler.StepSampler: This sampler is a subclass of SequentialSampler and is responsible for sampling the steps of an episode. We can either sample only a single step of a single episode or a single step of all episodes at once (standard behaviour as it is much more efficient). It defines several sampling pools: 'InitSamples', 'Policy','TransitionSampler', 'StayActiveSampler'. When creating the steps of an episode, first the InitSamples pool is called. This pool typically sets the initial state, e.g., copies the context to the state entry of the first time step. Subsequently, the StepSampler loops over the remaining pools ('Policy','TransitionSampler', 'StayActiveSampler') until no active samples are left. The Policy pool typically samples an action, the TransitionSampler pool samples the nextStates variable given the states and the action (typically done by a subclass of Environment.TransitionFunction) and the 'StayActiveSampler' determines wether an episode has terminated or not (see package Sampler.IsActiveStepSampler). The standard behavior is that all episodes are terminated after a certain number of time steps (implemented by Sampler.IsActiveStepSampler.IsActiveStepSampler). For all episodes that did not terminate a transition to the next time step is executed. The standard behaviour for a transition is that the state entries of the new time step are initiallized to the nextStates entries of the previous time steps, but also this behaviour can be adapted. When all episodes terminated the createSamples function of the StepSampler returns. The step sampler also adds another data entry at the level of the steps called 'timeSteps'. This data entry is automatically set by the createSamples function and corresponds to the time index of a sample. As we typically want to sample several episodes and not just steps, this class is never used directly but instantiated by the Sampler.EpisodeSamplerWithSteps sampler class. 
- Sampler.EpisodeSamplerWithSteps: This sampler combines the EpisodeSampler and the StepSampler. It is a subclass of the EpisodeSampler and instantiates the StepSampler. It connects the data manager of the EpsiodeSampler with the data manager of the StepSampler. In the 'Episodes' sampling pool of the EpisodeSampler, the createSamples function of the StepSampler is called, such that the single steps of an episode can be sampled. This class is the standard class for all sequential environemts that define a transition function from 'states' to 'nextStates'.



*/
