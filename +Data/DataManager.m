classdef DataManager < Common.IASObject & matlab.mixin.Heterogeneous
    % The data manager stores all properties of the data that we mantain for
    % the different experiments. It is organized hierarchically for storing
    % data on different time scales. For example, we can store data on the
    % level of the "episodes", e.g., "parameters", or on the level of the
    % single steps of an episode, e.g., "states" and "actions".
    %
    %@section datamanager_entry Data Entry
    % For each level of the hierarchy, we have an individual data manager,
    % which need to be connected with the command "setSubDataManager". For
    % each data entry, we have to set the dimensionality. We also can set
    % the range of the data entry and specify whether some dimensions of the
    % data entry are periodic or not.
    %
    %@section datamanager_alias Data Alias
    % In addition to data entries, we can define data alias
    % (see addDataAlias). A data alias can be seen as a pointer that points
    % to other data entries. It can point to a subIndex set of a single
    % data entry or of mulitple data entries. For example, we could have
    % the data entries "weights", "goal" and "goalVel" (describing the
    % parameters of a DMP). In order to learn all parameters at once, we
    % can define a data alias "parameters" that points to the
    % concantenation of "weights", "goal" and "goalVel".
    %
    %@section datamanager_functionality Additional functionality
    % The data manager also has the basic functionality you need to obtain
    % the properties of the data or to compute the level of the hierarchy
    % of a specific data entry. When registering a new data entry, always
    % be aware that we have to register it at the correct data manager for
    % the desired hierarchy. The data managers can be obtained by the
    % functions getDataManagerForName or getDataManagerForDepth.
    %
    %@section datamanager_lazy Lazy Feature Generation
    % Finally, the data managers also allow for lazy evaluations of features.
    % In this case, we can add FeatureGenerators.FeatureGenerator for specify data entries.
    % Everytime the data entry is retrieved from the data structure, the
    % FeatureGenerator is asked whether the value in the data entry is still
    % valid. To do so, each data entry that is generated by a feature
    % generator gets an additional data entry with the suffix "Tag". The
    % tag is used to check whether the feature values are still active. It
    % is recommended to use the two test files "+tests/testDataManager.m"
    % and "+tests/testDataManagerAlias.m" to get a better feeling for the
    % data management.
    
    properties (SetAccess = protected)
        dataEntries;
        dataAliases;
        dataName
        subDataManager
        numStepsStorage = 1;
        
        subDataManagerList;
        dataEntryDeepMap;
    end
    
    methods
        
        function [obj] = DataManager(dataName)
            % Creates a new data manager with a specific name (e.g.
            % episodes or steps).
            obj = obj@Common.IASObject();
            obj.dataEntries = containers.Map;
            obj.dataName = dataName;
            obj.dataAliases = struct;
        end
        
        function [entryPrefix] = getDataEntryPrefix(obj, entryName)
            % Returns the prefix of the entry name. The prefix depends on
            % the level of the hierarchy of the data entry (E.g., the
            % prefix is "steps." if a data entry is on the second layer
            % called "steps". The prefix can be used to register new data
            % entries at the same level as a known data entry.
            if (obj.dataEntries.isKey(elementName))
                entryPrefix = '';
            else
                if (~isempty(obj.subDataManager))
                    entryPrefix = [obj.subDataManager.getManagerName(), '.', obj.subDataManager.getDataEntryPrefix(entryName)];
                else
                    assert(false, 'Data entry not known!\n');
                end
            end
        end
        
        function [subDataManager] = getSubDataManager(obj)
            % Returns the data manager for the next level of the hierarchy.
            subDataManager = obj.subDataManager;
        end
        
        function [dataEntries] = getDataEntries(obj)
            % Returns the data entries (only of this data manager, not of
            % the submanagers.
            dataEntries = obj.dataEntries.values;
        end
        
        function [subDataManager] = setSubDataManager(obj, subDataManager)
            % Sets the data manager for the next level of the hierarchy. If
            % it is empty, there is no next level of the hierarchy.
            obj.subDataManager = subDataManager;
        end
        
        function [manager] = getDataManagerForName(obj, managerName)
            % Returns the data manager with a specific name "e.g.
            % episodes".
            if (strcmp(managerName, obj.dataName))
                manager = obj;
            else
                if (isempty(obj.subDataManager))
                    manager = [];
                else
                    manager = obj.subDataManager.getDataManagerForName(managerName);
                end
            end
        end
        
        function [dataManager] = getDataManagerForEntry(obj, elementName)
            % Returns the data manager that is responsible for a certain
            % entry.
            
            queryStructure = obj.checkQueryString(elementName);
            elementName = queryStructure.aliasName;
            
            
            if (isfield(obj.dataAliases, elementName))
                dataManager = obj;
            else
                assert(~isempty(obj.subDataManager));
                dataManager = obj.subDataManager.getDataManagerForEntry(elementName);
            end
        end
        
        function [dataManager] = getDataManagerForDepth(obj, depth)
            % Returns the data manager for the "depth" level of the
            % hierarchy.
            dataManager = obj.subDataManagerList(depth);
        end
        
        function [depth] = getDataManagerDepth(obj, dataManagerName)
            % Returns the depth of the datamanager with the specified name.
            depth = 1;
            while (~strcmp(obj.subDataManagerList(depth).getManagerName(), dataManagerName))
                depth = depth + 1;
                assert(depth <= length(obj.subDataManagerList), sprintf('policysearchtoolbox:Data:DataManager; DataManager %s does not exists!!', dataManagerName));
            end
        end
        
        function [depth] = getDataEntryDepth(obj, entryName)
            % Returns the depth of a data entry witht the specified name.
            if (iscell(entryName))
                queryStructure = obj.checkQueryString(entryName{1});
                elementName = queryStructure.aliasName;
                
                depth = obj.dataEntryDeepMap(elementName);
            else
                queryStructure = obj.checkQueryString(entryName);
                elementName = queryStructure.aliasName;
                
                depth = obj.dataEntryDeepMap(elementName);
            end
        end
        
        function [] = setStepsStorage(obj, numStepsStorage)
            % Set the standard size of a new data object (number of data
            % points).
            obj.numStepsStorage = numStepsStorage;
        end
        
        function [name] = getManagerName(obj, depth)
            % Gets the name for the data manager with specified depth (no
            % argument, the name of the current manager is returned).
            if (nargin == 1)
                name = obj.dataName;
            else
                manager = obj.subDataManagerList(depth);
                name = manager.getManagerName();
            end
        end
        
        function [] = setNumDimensions(obj, elementName, numDim)
            % Sets the number of dimensions for a certain data entry.
            % Note that this will not influence already created data
            % objects!
            queryStructure = obj.checkQueryString(elementName);
            elementName = queryStructure.aliasName;
            
            if (obj.dataEntries.isKey(elementName));
                tempStruct = obj.dataEntries(elementName);
                tempStruct.numDimensions = numDim;
                obj.dataEntries(elementName) = tempStruct;
            else
                manager = obj.getDataManagerForEntry(elementName);
                manager.setNumDimensions(elementName, numDim);
            end
        end
        
        function [] = setRange(obj, elementName, minRange, maxRange)
            % Self explanatory.
            queryStructure = obj.checkQueryString(elementName);
            elementName = queryStructure.aliasName;
            
            if (obj.dataEntries.isKey(elementName));
                if (size(minRange,1) > 1)
                    minRange = minRange';
                end
                
                if (size(maxRange,1) > 1)
                    maxRange = maxRange';
                end
                
                tempStruct = obj.dataEntries(elementName);
                tempStruct.minRange = minRange;
                tempStruct.maxRange = maxRange;
                
                obj.dataEntries(elementName) = tempStruct;
            else
                manager = obj.getDataManagerForEntry(elementName);
                manager.setRange(elementName, minRange, maxRange);
            end
            
        end
        
        function [] = setPeriodicity(obj, elementName, isPeriodic)
            % Sets whether some of the dimensions of a data entry are
            % peridic. isPeriodic should be a logical array.
            queryStructure = obj.checkQueryString(elementName);
            elementName = queryStructure.aliasName;
            
            if (obj.dataEntries.isKey(elementName));
                tempStruct = obj.dataEntries(elementName);
                tempStruct.isPeriodic = logical(isPeriodic);
                
                obj.dataEntries(elementName) = tempStruct;
            else
                manager = obj.getDataManagerForEntry(elementName);
                manager.setPeriodicity(elementName, isPeriodic);
            end
        end
        
        function [] = setRestrictToRange(obj, elementName, isRestrict)
            % Sets whether we want to limit a data entry to be within the
            % desired range. When a data entry is set in a data object, it
            % is automatically limited to the range if isRestrict is set to
            % true. The standard value of isRestrict for each data entry is
            % false. Typically the "actions" data entry, that contains the
            % motor torques is restricted to the specified range.
            if (obj.dataEntries.isKey(elementName));
                tempStruct = obj.dataEntries(elementName);
                tempStruct.restrictToRange = isRestrict;
                
                obj.dataEntries(elementName) = tempStruct;
            else
                manager = obj.getDataManagerForEntry(elementName);
                manager.setRestrictToRange(elementName, isRestrict);
            end
        end
        
        function [] = setSparse(obj, elementName, isSparse)
            % Sets wether a data entry should be stored as sparse
            % matrix
            if (obj.dataEntries.isKey(elementName));
                tempStruct = obj.dataEntries(elementName);
                tempStruct.isSparse = isSparse;
                
                obj.dataEntries(elementName) = tempStruct;
            else
                manager = obj.getDataManagerForEntry(elementName);
                manager.setSparse(elementName, isSparse);
            end
        end
        
        function [isSparse] = isSparse(obj, elementName)
            % Returns whether a data entry gets automatically limited to its
            % range.
            if (isfield(obj.dataAliases, elementName));
                if (~isempty(obj.dataAliases.(elementName).entryNames))
                    elementName2 = obj.dataAliases.(elementName).entryNames{1};
                    tempStruct = obj.dataEntries(elementName2);
                    isSparse = tempStruct.isSparse;
                else
                    isSparse = false;
                end
            else
                manager = obj.getDataManagerForEntry(elementName);
                assert(manager ~= obj);
                isSparse = manager.isSparse(elementName);
                %isRestrict =1; %%bug recursion
            end
        end
        
        function [isRestrict] = isRestrictToRange(obj, elementName)
            % Returns whether a data entry gets automatically limited to its
            % range.
            if (isfield(obj.dataAliases, elementName));
                if (~isempty(obj.dataAliases.(elementName).entryNames))
                    elementName2 = obj.dataAliases.(elementName).entryNames{1};
                    tempStruct = obj.dataEntries(elementName2);
                    isRestrict = tempStruct.restrictToRange;
                else
                    isRestrict = false;
                end
            else
                manager = obj.getDataManagerForEntry(elementName);
                assert(manager ~= obj);
                isRestrict = manager.isRestrictToRange(elementName);
                %isRestrict =1; %%bug recursion
            end
        end
        
        function [] = setFeatureGenerator(obj, elementName, featureGenerator)
            % Sets a FeatureGenerators.FeatureGenerator for the specified
            % data entry. FeatureGenerators implement a lazy evaluation for
            % certain data entries. The function automatically creates a
            % new data entry with suffix "Tag" that stores the feature tag.
            % The feature tag is used to compute whether the feature needs
            % to be updated or not.
            assert(obj.dataEntries.isKey(elementName));
            
            tempStruct = obj.dataEntries(elementName);
            tempStruct.featureGenerator = featureGenerator;
            
            obj.addDataEntry([elementName, 'Tag'], 1);
            obj.dataEntries(elementName) = tempStruct;
        end
        
        function [] = addDataEntry(obj, elementName, numDim, minRange, maxRange)
            % Function for adding a new data entry with the name
            % elementName. If the same data entry already exists, then the
            % properties are overwritten. minRange and maxRange are
            % optional arguments (standard values are a vector of -1 and
            % +1). Both arguments need to be row vectors with the same size
            % as the specified dimensionality. The function automatically
            % adds a data alias pointing to the same data entry.
            pointIndex = strfind(elementName, '.');
            
            if (~exist('minRange', 'var') || isempty(minRange) )
                minRange = -ones(1,numDim);
            end
            
            if (~exist('maxRange', 'var') || isempty(maxRange) )
                maxRange = ones(1,numDim);
            end
            
            if (size(minRange,1) > 1)
                minRange = minRange';
            end
            
            if (size(maxRange,1) > 1)
                maxRange = maxRange';
            end
            
            if (numel(minRange) == 1 && numDim > 1)
                minRange = minRange * ones(1, numDim);
            end
            
            if (numel(maxRange) == 1 && numDim > 1)
                maxRange = maxRange * ones(1, numDim);
            end
            
            if (~isempty(pointIndex))
                managerName = elementName(1:(pointIndex - 1));
                realElementName = elementName((pointIndex + 1):end);
                
                manager = obj.getDataManagerForName(managerName);
                manager.addDataEntry(realElementName, numDim, minRange, maxRange);
            else
                newDataEntry.name = elementName;
                newDataEntry.numDimensions = numDim;
                newDataEntry.minRange = minRange;
                newDataEntry.maxRange = maxRange;
                newDataEntry.featureGenerator = [];
                newDataEntry.isPeriodic = false(1, numDim);
                newDataEntry.restrictToRange = false;
                newDataEntry.isSparse = false;
                obj.dataEntries(elementName) = newDataEntry;
                
                obj.addDataAlias(elementName, elementName, 1:numDim);
            end
            obj.finalizeDataManager();
        end
        
        function [] = addDataEntryForDepth(obj, level, elementName, numDim, varargin)
            % Function for adding a new data entry at a desired level of
            % hierarchy. The level specifies the depth of the data entry
            
            dataManagerForDepth = obj.getDataManagerForDepth(level);
            dataManagerForDepth.addDataEntry(elementName, numDim, varargin{:});
            
            obj.finalizeDataManager();
        end
        
        function [] = addDataAliasForDepth(obj, level, varargin)
            % Function for adding a new data entry at a desired level of
            % hierarchy. The level specifies the depth of the data entry
            
            dataManagerForDepth = obj.getDataManagerForDepth(level);
            dataManagerForDepth.addDataAlias(varargin{:});
            
            obj.finalizeDataManager();
        end
        
        
        function [] = addDataEntryIfNotExistOrIsAlias(obj, elementName, numDim, varargin)
            if ( ~obj.isDataAlias(elementName) && ~obj.isDataEntry(elementName) )
                obj.addDataEntry(elementName, numDim, varargin{:});
            end
        end
        
        function addDataAlias(obj, aliasName, entryNames, indexList)
            % Adds a data alias with the name "aliasName". entryNames
            % should be a cell array of data entries and indexList a cell
            % array of subIndices to these data entries. indexList is
            % optional, the standard value is ":", meaning the alias should
            % point to all dimensions of the data entry. An alias is the
            % concatenation of all dataEntries in the entryNames list
            % (indiced with the corresponding indexList). The function
            % addDataAlias can also be called sequentially for the same
            % alias. If a data alias already exists, the data entries
            % listed in entryNames are added to the data entries that have
            % been specified so far for the data alias.
            if (~exist('indexList', 'var'))
                if (iscell(entryNames))
                    [indexList{1:length(entryNames)}] = deal(':');
                else
                    indexList = {':'};
                end
            end
            
            if (~iscell(entryNames))
                entryNames = {entryNames};
            end
            
            if (~iscell(indexList))
                indexList = {indexList};
            end
            
            if (isempty(entryNames) || all(obj.dataEntries.isKey(entryNames)))
                if (isfield(obj.dataAliases, aliasName))
                    for i = 1:length(indexList)
                        isAliasAdded = cellfun(@(param_)strcmp(param_, entryNames{i}), obj.dataAliases.(aliasName).entryNames);
                        if (any(isAliasAdded))
                            index = logical(isAliasAdded);
                            
                            obj.dataAliases.(aliasName).indexList{index} = indexList{i};
                        else
                            
                            obj.dataAliases.(aliasName).entryNames = {obj.dataAliases.(aliasName).entryNames{:}, entryNames{i}};
                            if (isempty(obj.dataAliases.(aliasName).indexList) || isempty(obj.dataAliases.(aliasName).indexList{1}))
                                obj.dataAliases.(aliasName).indexList = {indexList{i}};
                            else
                                obj.dataAliases.(aliasName).indexList = {obj.dataAliases.(aliasName).indexList{:}, indexList{i}};
                            end
                        end
                        
                        
                        [obj.dataAliases.(aliasName).entryNames, indexUnique] = unique({obj.dataAliases.(aliasName).entryNames{:}, entryNames{:}}, 'stable');
                        obj.dataAliases.(aliasName).entryNames = {obj.dataAliases.(aliasName).entryNames{indexUnique}};
                        if (isempty(obj.dataAliases.(aliasName).indexList) || isempty(obj.dataAliases.(aliasName).indexList{1}))
                            obj.dataAliases.(aliasName).indexList = indexList;
                        else
                            obj.dataAliases.(aliasName).indexList = {obj.dataAliases.(aliasName).indexList{:}, indexList{:}};
                        end
                        obj.dataAliases.(aliasName).indexList = {obj.dataAliases.(aliasName).indexList{indexUnique}};
                        if (~iscell(obj.dataAliases.(aliasName).indexList))
                            obj.dataAliases.(aliasName).indexList = {obj.dataAliases.(aliasName).indexList};
                        end
                    end
                else
                    obj.dataAliases.(aliasName).entryNames = entryNames;
                    obj.dataAliases.(aliasName).indexList = indexList;
                end
                
                numDim = 0;
                entryNamesTotal = obj.dataAliases.(aliasName).entryNames;
                indexListTotal = obj.dataAliases.(aliasName).indexList;
                for i = 1:length(indexListTotal)
                    if (~ischar(indexListTotal{i}))
                        numDim = numDim + length(indexListTotal{i});
                    else
                        numDim = numDim + obj.dataEntries(entryNamesTotal{i}).numDimensions;
                    end
                end
                
                obj.dataAliases.(aliasName).numDimensions = numDim;
            else
                assert(~isempty(obj.subDataManager), sprintf('DataEntry %s is not known for Alias %s\n', cell2mat(entryNames), aliasName));
                obj.subDataManager.addDataAlias(aliasName, entryNames, indexList);
            end
            obj.finalizeDataManager();
        end
        
        function [aliasStructure] = getAliasStructure(obj, elementName)
            % The alias structure of a specific data entry contains all data aliases and the data
            % entries where they point to. The data alias structure is used
            % to determine whether an alias (or entry) is member of a
            % data manager. Each data entry automatically also gets
            % registered as alias (pointing to itself with a full index
            % list). If the alias is part of a sub-datamanager,
            if (isfield(obj.dataAliases, elementName))
                aliasStructure = obj.dataAliases.(elementName);
            elseif (~isempty(obj.subDataManager))
                aliasStructure = obj.subDataManager.getAliasStructure(elementName);
            else
                assert(false,sprintf('Data entry %s not known', elementName));
            end
        end
        
        function [names] = getAliasNames(obj)
            % Returns the names of all aliases (including the
            % subdatamanagers).
            names = fieldnames(obj.dataAliases)';
            if (~isempty(obj.subDataManager))
                names = [names, obj.subDataManager.getAliasNames()];
            end
        end
        
        function [names] = getElementNames(obj)
            % Returns the names of all data entries (including the
            % subdatamanagers).
            names = obj.dataEntries.keys;
            if (~isempty(obj.subDataManager))
                names = [names, obj.subDataManager.getElementNames()];
            end
        end
        
        function [names] = getAliasNamesLocal(obj)
            % Returns the names of all data entries (only of this data
            % manager).
            names = fieldnames(obj.dataAliases);
        end
        
        function [names] = getElementNamesLocal(obj)
            % Returns the names of all data entries (only this data
            % manager).
            names = obj.dataEntries.keys;
        end
        
        function [isKey] = isDataAlias(obj, elementName)
            % Returns whether the given name has been defined as data
            % alias on this or on the submanagers.
            if (length(elementName) > 3 && strcmp(elementName(end-2:end), 'Tag'))
                elementName = elementName(1:end-3);
            end
            
            if (length(elementName) > 8 && strcmp(elementName(end-7:end), 'NoUpdate'))
                elementName = elementName(1:end-8);
            end
            
            queryStructure = obj.checkQueryString(elementName);
            elementName = queryStructure.aliasName;
            
            
            isKey = isfield(obj.dataAliases, elementName);
            if (~all(isKey) && ~isempty(obj.subDataManager))
                if (iscell(elementName))
                    isKey(~isKey) = obj.subDataManager.isDataAlias(elementName(~isKey));
                else
                    isKey = obj.subDataManager.isDataAlias(elementName);
                end
            end
        end
        
        function [isKey] = isDataEntry(obj, elementName)
            % Returns whether the given name has been defined as data
            % entry on this or on the submanagers.
            queryStructure = obj.checkQueryString(elementName);
            elementName = queryStructure.aliasName;
            
            isKey = obj.dataEntries.isKey(elementName);
            if (~isKey && ~isempty(obj.subDataManager))
                isKey = obj.subDataManager.isDataEntry(elementName);
            end
        end
        
        function [numDim] = getNumDimensions(obj, elementName)
            % Returns the dimensionality of a given data entry (or alias).
            % Also works if the name has been registered in a submanager.
            if (isempty(elementName))
                numDim = 0;
            else
                if (iscell(elementName))
                    numDim = 0;
                    for i = 1:length(elementName)
                        numDim = numDim + obj.getNumDimensions(elementName{i});
                    end
                else
                    queryStructure = obj.checkQueryString(elementName);
                    elementName = queryStructure.aliasName;
                    
                    if (isfield(obj.dataAliases, elementName))
                        numDim = obj.dataAliases.(elementName).numDimensions;
                    elseif (~isempty(obj.subDataManager))
                        numDim = obj.subDataManager.getNumDimensions(elementName);
                    else
                        assert(false,sprintf('Data entry %s not known', elementName));
                    end
                end
            end
        end
        
        function [minRange] = getMinRange(obj, aliasName)
            % Returns the minRange of a given data entry (or alias).
            % Also works if the name has been registered in a submanager.
            if (iscell(aliasName))
                minRange = obj.getMinRange(aliasName{1});
                if (length(aliasName) > 1)
                    minRange = [minRange, obj.getMinRange(aliasName{2:end})];
                end
            else
                queryStructure = obj.checkQueryString(aliasName);
                aliasName = queryStructure.aliasName;
                
                if (isfield(obj.dataAliases, aliasName))
                    elementNames = obj.dataAliases.(aliasName).entryNames;
                    indexList = obj.dataAliases.(aliasName).indexList;
                    minRange = zeros(1, obj.dataAliases.(aliasName).numDimensions);
                    index = 0;
                    for i = 1:length(indexList)
                        tempStruct = obj.dataEntries(elementNames{i});
                        tempMinRange = tempStruct.minRange(indexList{i});
                        
                        minRange(index + (1:length(tempMinRange))) = tempMinRange;
                        index = index + length(tempMinRange);
                    end
                elseif (~isempty(obj.subDataManager))
                    minRange = obj.subDataManager.getMinRange(aliasName);
                else
                    assert(false,sprintf('Data entry %s not known', aliasName));
                end
            end
        end
        
        function [maxRange] = getMaxRange(obj, aliasName)
            % Returns the maxRange of a given data entry (or alias).
            % Also works if the name has been registered in a submanager.
            if (iscell(aliasName))
                maxRange = obj.getMaxRange(aliasName{1});
                if (length(aliasName) > 1)
                    maxRange = [maxRange, obj.getMaxRange(aliasName{2:end})];
                end
            else
                queryStructure = obj.checkQueryString(aliasName);
                aliasName = queryStructure.aliasName;
                
                if (isfield(obj.dataAliases, aliasName))
                    elementNames = obj.dataAliases.(aliasName).entryNames;
                    indexList = obj.dataAliases.(aliasName).indexList;
                    maxRange = zeros(1, obj.dataAliases.(aliasName).numDimensions);
                    index = 0;
                    for i = 1:length(indexList)
                        tempStruct = obj.dataEntries(elementNames{i});
                        tempMaxRange = tempStruct.maxRange(indexList{i});
                        
                        maxRange(index + (1:length(tempMaxRange))) = tempMaxRange;
                        index = index + length(tempMaxRange);
                    end
                elseif (~isempty(obj.subDataManager))
                    maxRange = obj.subDataManager.getMaxRange(aliasName);
                else
                    assert(false,sprintf('Data entry %s not known', aliasName));
                end
            end
        end
        
        function [isPeriodic] = getPeriodicity(obj, aliasName)
            % Returns the isPeriodic field of a given data entry (or alias).
            % Also works if the name has been registered in a submanager.
            
            
            if (iscell(aliasName))
                isPeriodic = [];
                for i = 1:length(aliasName)
                    isPeriodic = [isPeriodic, obj.getPeriodicity(aliasName{i})];
                end
                
                return;
            end
            
            queryStructure = obj.checkQueryString(aliasName);
            aliasName = queryStructure.aliasName;
            
            if (isfield(obj.dataAliases, aliasName))
                elementNames = obj.dataAliases.(aliasName).entryNames;
                indexList = obj.dataAliases.(aliasName).indexList;
                isPeriodic = zeros(1, obj.dataAliases.(aliasName).numDimensions);
                index = 0;
                for i = 1:length(elementNames)
                    tempStruct = obj.dataEntries(elementNames{i});
                    isPeriodicTemp = tempStruct.isPeriodic(indexList{i});
                    
                    isPeriodic(index + (1:length(isPeriodicTemp))) = isPeriodicTemp;
                    index = index + length(isPeriodicTemp);
                end
                
            elseif (~isempty(obj.subDataManager))
                isPeriodic = obj.subDataManager.getPeriodicity(aliasName);
            else
                assert(false,sprintf('Data entry %s not known', aliasName));
            end
            isPeriodic = logical(isPeriodic);
        end
        
        function [restrictToRange] = getRestrictToRange(obj, aliasName)
            if (isfield(obj.dataAliases, aliasName))
                assert(strcmp(obj.dataAliases.(aliasName).entryNames{1}, aliasName), 'Restrict To Range is only allowed for data entries, not for aliases!');
                elementName = obj.dataAliases.(aliasName).entryNames{1};
                tempStruct = obj.dataEntries(elementName);
                restrictToRange = tempStruct.restrictToRange;
            elseif (~isempty(obj.subDataManager))
                restrictToRange = obj.subDataManager.getRestrictToRange(aliasName);
            else
                assert(false,sprintf('Data entry %s not known', aliasName));
            end
        end
        
        function [range] = getRange(obj, elementName)
            % Computes maxRange - minRange.
            range = obj.getMaxRange(elementName) - obj.getMinRange(elementName);
        end
        
        function [featureGenerator] = getFeatureGenerator(obj, elementName)
            % Returns the feature generator of the specified data entry
            % (also works for sub data managers).
            if (obj.dataEntries.isKey(elementName))
                featureGenerator = obj.dataEntries(elementName).featureGenerator;
            elseif (~isempty(obj.subDataManager))
                featureGenerator = obj.subDataManager.getFeatureGenerator(elementName);
            else
                assert(false,sprintf('Data entry %s not known', elementName));
            end
        end
        
        function [isFeature] = isFeature(obj, elementName)
            % Returns whether a feature manager has been defined for the
            % data entry (also checks sub data managers).
            
            if (obj.dataEntries.isKey(elementName))
                isFeature = ~isempty(obj.dataEntries(elementName).featureGenerator);
            elseif (~isempty(obj.subDataManager))
                isFeature = obj.subDataManager.isFeature(elementName);
            else
                isFeature = false;
            end
        end
        
        function dataStructure = getDataStructure(obj, numElements)
            % Returns an empty hierarchical data structure with
            % numElements. The data structure contains a matrix for each
            % data entry (numElements x numDim) and a structure array
            % containing the data structure of the subdatamanager for each
            % element. The structure array gets the name of the
            % subdatamanager. This function is called by the data object,
            % should not be called by the user!
            dataEntries = obj.dataEntries.values;
            
            dataStructure = struct();
            
            if (nargin == 1)
                numElements = obj.numStepsStorage;
            end
            numElementsLocal = numElements(1);
            dataStructure.numElements = numElementsLocal;
            
            for i = 1:length(dataEntries)
                if (~dataEntries{i}.isSparse)
                    dataStructure.(dataEntries{i}.name) = zeros(numElementsLocal,dataEntries{i}.numDimensions);
                else
                    dataStructure.(dataEntries{i}.name) = spalloc(dataEntries{i}.numDimensions, numElementsLocal, numElementsLocal);                    
                end
                %                 if (~isempty(dataEntries{i}.featureGenerator))
                %                     dataStructure.([dataEntries{i}.name, 'Tag']) = -ones(numElements,1);
                %                 end
            end
            
            if (~isempty(obj.subDataManager))
                if (length(numElements) > 1)
                    tempArg = {numElements(2:end)};
                else
                    tempArg = {};
                end
                
                if (numElementsLocal > 0)
                    for j = 1:numElementsLocal
                        dataStructure.(obj.subDataManager.getManagerName())(j) = obj.subDataManager.getDataStructure(tempArg{:});
                    end
                    
                    dataStructure.(obj.subDataManager.getManagerName()) = dataStructure.(obj.subDataManager.getManagerName())';
                else
                    dataStructure.(obj.subDataManager.getManagerName()) = [];
                end
            end
        end
        
        function [targetData] = createNewDataStructureFromCopyIndex(obj, origData, indexOrig)
            % Creates a new data strcture and copied the values of the
            % elements defined by indexOrig from the origData. Also copied
            % the elements of the data of the lower levels. This
            % function is called by the data object, should not be called by the user!
            targetData = obj.getDataStructure(length(indexOrig));
            dataEntries = obj.dataEntries.values;
            
            for i = 1:length(dataEntries)
                targetData.(dataEntries{i}.name) = origData.(dataEntries{i}.name)(indexOrig,:);
                %                 if (~isempty(dataEntries{i}.featureGenerator))
                %                     dataStructure.([dataEntries{i}.name, 'Tag']) = origData.([dataEntries{i}.name, 'Tag'])(indexOrig,:);
                %                 end
            end
            
            if (~isempty(obj.subDataManager))
                targetData.(obj.subDataManager.getManagerName()) = origData.(obj.subDataManager.getManagerName())(indexOrig);
            end
            if islogical(indexOrig)
                targetData.numElements = sum(indexOrig);
            else
                targetData.numElements = length(indexOrig);
            end
        end
        
        function [targetData] = copyDataStructureIndex(obj, targetData, origData, indexTarget, indexOrig)
            % Copies the data from origData (with indexOrig) to the
            % targetData structure (with indexTarget). This
            % function is called by the data object, should not be called by the user!
            dataEntries = obj.dataEntries.values;
            
            for i = 1:length(dataEntries)
                targetData.(dataEntries{i}.name)(indexTarget,:) = origData.(dataEntries{i}.name)(indexOrig,:);
                %                 if (~isempty(dataEntries{i}.featureGenerator))
                %                     dataStructure.([dataEntries{i}.name, 'Tag']) = origData.([dataEntries{i}.name, 'Tag'])(indexOrig,:);
                %                 end
            end
            
            if (~isempty(obj.subDataManager))
                targetData.(obj.subDataManager.getManagerName())(indexTarget) = origData.(obj.subDataManager.getManagerName())(indexOrig);
            end
            targetData.numElements = origData.numElements;
        end
        
        function [targetData] = copyValuesFromDataStructure(obj, targetData, copyData)
            targetData.numElements = copyData.numElements;
            
            fieldNames = fieldnames(targetData);
            for i = 1:length(fieldNames)
                if (isfield(copyData, fieldNames{i}))
                    targetData.(fieldNames{i}) = copyData.(fieldNames{i});
                else
                    if (~obj.isSparse(fieldNames{i}))
                        targetData.(fieldNames{i}) = zeros(copyData.numElements, obj.getNumDimensions(fieldNames{i}));
                    else
                        targetData.(fieldNames{i}) = spalloc(obj.getNumDimensions(fieldNames{i}), copyData.numElements, copyData.numElements);                    
                    end
                    
                end
            end
            
            if (~isempty(obj.subDataManager) && targetData.numElements > 0)
                subDataManagerName = obj.subDataManager.getManagerName();
                
                targetData.(subDataManagerName) = obj.subDataManager.getDataStructure(copyData.(subDataManagerName)(1).numElements);
                targetData.(subDataManagerName) = obj.subDataManager.copyValuesFromDataStructure(targetData.(subDataManagerName)(1), copyData.(subDataManagerName)(1));
                for i = 2:copyData.numElements
                    targetData.(subDataManagerName)(i,1) = obj.subDataManager.getDataStructure(copyData.(subDataManagerName)(i).numElements);
                    targetData.(subDataManagerName)(i,1) = obj.subDataManager.copyValuesFromDataStructure(targetData.(subDataManagerName)(i), copyData.(subDataManagerName)(i));
                end
            end
        end
        
        function [newDataStructure] = getPartialDataStructure(obj, dataStructure, partialDataEntries, dataIndices)
            % Returns a partial datastructure of the given dataStructure
            % which only contains the specified partialDataEntries. It also
            % only returns the data points that are defined in dataIndices
            % (that is optional, otherwise every data point is copied). This
            % function is called by the data object, should not be called
            % by the user!
            if (~exist('dataIndices','var') || (length(dataIndices) == 1 && ischar(dataIndices) && dataIndices == ':'))
                dataIndices = true(dataStructure.numElements, 1);
            end
            idxDataStructure = find(dataIndices==1);
            
            newDataStructure = struct();
            
            dataEntries = obj.getElementNamesLocal();
            
            if (~ischar(dataIndices))
                newDataStructure.numElements = sum(dataIndices);
            end
            for i = 1:length(dataEntries)
                if (any(strcmp(partialDataEntries, dataEntries{i})))
                    newDataStructure.(dataEntries{i}) = dataStructure.(dataEntries{i})(dataIndices, :);
                end
            end
            
            if (~isempty(obj.subDataManager))
                subDataManagerName = obj.subDataManager.getManagerName();
                dataEntries = obj.subDataManager.getElementNamesLocal();
                
                
                newDataStructure.(subDataManagerName) = struct('numElements', {dataStructure.(subDataManagerName)(dataIndices).numElements});
                newDataStructure.(subDataManagerName) = newDataStructure.(subDataManagerName)';
                for i = 1:length(dataEntries)
                    if (any(strcmp(partialDataEntries, dataEntries{i})))
                        [newDataStructure.(subDataManagerName)(:).(dataEntries{i})] = deal(dataStructure.(subDataManagerName)(dataIndices).(dataEntries{i}));
                    end
                end
                subSubDataManager = obj.subDataManager.getSubDataManager();
                if (~isempty(subSubDataManager))
                    subSubDataManagerName = subSubDataManager.getManagerName();
                    for i = 1:newDataStructure.numElements
                        for j = 1:newDataStructure.(subDataManagerName)(i).numElements
                            newDataStructure.(subDataManagerName)(i).(subSubDataManagerName)(j) = ...
                                subSubDataManager.getPartialDataStructure(...
                                dataStructure.(subDataManagerName)(idxDataStructure(i)).(subSubDataManagerName)(j), partialDataEntries, ':');
                        end
                    end
                end
            end
        end
        
        function [dataStructure] = addDataPoints(obj, dataStructure, numElements)
            % Reserves more storeage for a data structure (also works
            % hierarchically). numElements can be a vector that also
            % contains the number of data points to add for the lower
            % levels of the hierarchy). This
            % function is called by the data object, should not be called
            % by the user!
            dataEntries = obj.dataEntries.values;
            
            for i = 1:length(dataEntries)
                if dataEntries{i}.isSparse 
                    dataStructure.(dataEntries{i}.name) = [dataStructure.(dataEntries{i}.name), spalloc(dataEntries{i}.numDimensions,numElements(1), numElements(1))];
                else
                    dataStructure.(dataEntries{i}.name) = [dataStructure.(dataEntries{i}.name); zeros(numElements(1),dataEntries{i}.numDimensions)];
                end
                %                 if (~isempty(dataEntries{i}.featureGenerator))
                %                     dataStructure.([dataEntries{i}.name, 'Tag']) = [dataStructure.([dataEntries{i}.name, 'Tag']), - ones(numElements(1),dataEntries{i}.numDimensions)];
                %                 end
            end
            dataStructure.numElements = dataStructure.numElements + numElements;
            if (~isempty(obj.subDataManager))
                if (length(numElements) > 1)
                    tempArg = {numElements(2:end)};
                else
                    tempArg = {};
                end
                startIndex = 1;
                if (isempty(dataStructure.(obj.subDataManager.getManagerName())))
                    dataStructure.(obj.subDataManager.getManagerName()) = obj.subDataManager.getDataStructure(tempArg{:});
                    startIndex = 2;
                end
                
                for j = startIndex:numElements(1)
                    dataStructure.(obj.subDataManager.getManagerName())(end  + 1) = obj.subDataManager.getDataStructure(tempArg{:});
                end
                
                if (size(dataStructure.(obj.subDataManager.getManagerName()),1) < size(dataStructure.(obj.subDataManager.getManagerName()),2))
                    dataStructure.(obj.subDataManager.getManagerName()) = dataStructure.(obj.subDataManager.getManagerName())';
                end
            end
        end
        
        function [dataStructure] = removeLastNElements(obj, dataStructure, numElements)
            % Removes the last N data points. This function is called by
            % the data object, should not be called by the user!
            dataEntries = obj.dataEntries.values;
            
            dataStructure.numElements = max(0, dataStructure.numElements - numElements);
            
            for i = 1:length(dataEntries)
                if (~dataEntries{i}.isSparse)
                    dataStructure.(dataEntries{i}.name) = dataStructure.(dataEntries{i}.name)(1:end - numElements, :);
                else
                    dataStructure.(dataEntries{i}.name) = dataStructure.(dataEntries{i}.name)(:, 1:end - numElements);
                end
                %                 if (~isempty(dataEntries{i}.featureGenerator))
                %                     dataStructure.([dataEntries{i}.name, 'Tag']) = dataStructure.([dataEntries{i}.name, 'Tag'])(1:end - numElements, :);
                %                 end
            end
            
            if (~isempty(obj.subDataManager))
                dataStructure.(obj.subDataManager.getManagerName()) = dataStructure.(obj.subDataManager.getManagerName())(1:end-numElements);
            end
        end
        
        function [dataStructure] = deleteDataIndex(obj, dataStructure, keepIndices)
            % Removes data points which are not in the specified
            % keepIndices list. Only works for data structures. This
            % function is called by the data object, should not be called
            % by the user!
            dataEntries = obj.dataEntries.values;
            
            for i = 1:length(dataEntries)
                dataStructure.(dataEntries{i}.name) = dataStructure.(dataEntries{i}.name)(keepIndices, :);
                %                 if (~isempty(dataEntries{i}.featureGenerator))
                %                     dataStructure.([dataEntries{i}.name, 'Tag']) = dataStructure.([dataEntries{i}.name, 'Tag'])(keepIndices, :);
                %                 end
            end
            
            if (~isempty(obj.subDataManager))
                dataStructure.(obj.subDataManager.getManagerName()) = dataStructure.(obj.subDataManager.getManagerName())(keepIndices);
            end
            dataStructure.numElements = sum(keepIndices);
        end
        
        function [data1] = mergeDataStructures(obj, data1, data2)
            % Merges the given data structures. This function is called by
            % the data object, should not be called by the user!
            dataEntries = obj.dataEntries.values;
            
            for i = 1:length(dataEntries)
                if (~isfield(data1, dataEntries{i}.name))
                    numElements = data1.numElements;
                    numDimensions = dataEntries{i}.numDimensions;
                    if (~dataEntries{i}.isSparse)
                        data1.(dataEntries{i}.name) = [zeros(numElements, numDimensions); data2.(dataEntries{i}.name)];
                    else
                        data1.(dataEntries{i}.name) = [spalloc(numDimensions, numElements, numElements); data2.(dataEntries{i}.name)];                        
                    end
                else
                    data1.(dataEntries{i}.name) = [data1.(dataEntries{i}.name); data2.(dataEntries{i}.name)];
                end
                
                %                 if (~isempty(dataEntries{i}.featureGenerator))
                %                     dataStructure.([dataEntries{i}.name, 'Tag']) = [data1.([dataEntries{i}.name, 'Tag']); data2.([dataEntries{i}.name, 'Tag'])];
                %                 end
            end
            
            if (~isempty(obj.subDataManager))
                data1.(obj.subDataManager.getManagerName()) = [data1.(obj.subDataManager.getManagerName()); data2.(obj.subDataManager.getManagerName())];
            end
            data1.numElements = data1.numElements + data2.numElements;
        end
        
        function data = getDataObject(obj, numElements)
            % Creates a new data object with numElements data points. For
            % herarchical data objects, numElements can be a vector
            % defining the numElements for each layer of the hierarchy. If
            % no numElements are defined, the size of the data object is
            % the standard size (numStepsStorage).
            if (nargin == 1)
                numElements = obj.numStepsStorage;
            end
            
            data = Data.Data(obj, obj.getDataStructure(numElements));
        end
        
        function [] = resetFeatureTags(obj, dataStructure)
            % Resets all feature tags of a data structure. This
            % function is called by the data object, should not be called
            % by the user!
            dataEntries = obj.dataEntries.values;
            
            for i = 1:length(dataEntries)
                if (~isempty(dataEntries{i}.featureGenerator))
                    dataStructure.([dataEntries{i}.name, 'Tag']) = -ones(size(dataStructure.([dataEntries{i}.name, 'Tag'])));
                end
            end
            
            if (~isempty(obj.subDataManager))
                for i = 1:length(dataStructure.(obj.subDataManager.getManagerName()))
                    obj.subDataManager.resetFeatureTags(dataStructure.(obj.subDataManager.getManagerName())(i) );
                end
            end
        end
        
        function [queryStructure] = checkQueryString(obj, queryName, varargin)
            queryStructure.restrictRange = false;
            queryStructure.layerIndex = varargin;
            queryStructure.aliasName = queryName;           
            
            if (length(queryName) > 10 && strcmp(queryName(1:10), 'restricted'))
                queryStructure.aliasName = [lower(queryName(11)), queryName(12:end)];
                queryStructure.restrictRange = true;
            end            
           
        end
        
        
        function [] = finalizeDataManager(obj)
            % Finalize data manager. This function needs to be called to
            % assembly the necessary data structures for the alias and the
            % depthmap for the data managers. It is called automatically
            % everytime a data entry is added to the data manager. It also
            % calls finalize of the submanagers.
            obj.subDataManagerList = [];
            subDataManager = obj;
            obj.dataEntryDeepMap = containers.Map;
            
            depth = 1;
            while (~isempty(subDataManager))
                
                entries = subDataManager.getAliasNamesLocal();
                
                for i = 1:length(entries)
                    obj.dataEntryDeepMap(entries{i}) = depth;
                end
                
                if (depth > 1)
                    subDataManager.finalizeDataManager();
                    obj.subDataManagerList(depth) = subDataManager;
                else
                    obj.subDataManagerList = obj;
                end
                
                depth = depth + 1;
                subDataManager = subDataManager.getSubDataManager();
            end
        end
        
    end
    
    methods (Access=protected)
        
        function [values] = getDataEntryCell(obj)
            values = obj.dataEntries.values;
            if (~iesmpty(obj.subDataManager))
                values = {values, obj.subDataManager.getDataEntryCell()};
            end
        end
        
        function [values] = getDataEntryMap(obj)
            values = obj.dataEntries;
        end
        
    end
    
end
